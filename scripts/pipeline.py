#!/usr/bin/env python3
from __future__ import annotations

import argparse
import datetime as dt
from pathlib import Path
import yaml

ROOT = Path(__file__).resolve().parents[1]
RUNS = ROOT / "runs"


def load_yaml(path: Path):
    with path.open() as f:
        return yaml.safe_load(f)


def write_yaml(path: Path, data):
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w") as f:
        yaml.safe_dump(data, f, sort_keys=False)


def task_create(project_path: Path, goal: str, accepts: list[str]):
    project = load_yaml(project_path)
    now = dt.datetime.now(dt.UTC)
    run_id = now.strftime("run-%Y%m%d-%H%M%S")
    run_dir = RUNS / run_id
    run_dir.mkdir(parents=True, exist_ok=False)

    task = {
        "id": run_id,
        "goal": goal,
        "scope": [project["project"], project["path"]],
        "acceptance": accepts or ["(none provided)"],
        "files_touched": [],
        "tests": [],
        "llm_required": False,
        "model_policy": project.get("model_policy", "subagent_policy"),
        "project": project["project"],
        "repo": project["repo"],
        "path": project["path"],
    }

    write_yaml(run_dir / "task.yaml", task)
    (run_dir / "REPORT.md").write_text("# Run Report\n\nPending.\n")

    # auto-create orchestration run packet with same run_id
    orch_script = ROOT / "orchestration" / "run_packet.py"
    if orch_script.exists():
        import subprocess
        subprocess.run([
            "python3",
            str(orch_script),
            "--objective", goal,
            "--scope", project["project"],
            "--run-id", run_id,
            *sum([["--criterion", c] for c in (accepts or [])], [])
        ], check=True)

    print(run_dir)


def main():
    p = argparse.ArgumentParser(description="Deterministic pipeline runner")
    sp = p.add_subparsers(dest="cmd", required=True)

    c = sp.add_parser("task-create")
    c.add_argument("project")
    c.add_argument("--goal", required=True)
    c.add_argument("--accept", action="append", default=[])

    r = sp.add_parser("run")
    r.add_argument("--task", required=True)

    a = sp.add_parser("approve")
    a.add_argument("--run-id", required=True)

    args = p.parse_args()

    if args.cmd == "task-create":
        task_create(Path(args.project), args.goal, args.accept)
        return

    if args.cmd == "approve":
        run_id = args.run_id
        run_dir = ROOT / "orchestration" / "runs" / run_id
        checklist = run_dir / "CHECKLIST.md"
        if not checklist.exists():
            raise SystemExit(f"Checklist not found for {run_id}")

        # auto-check when required outputs exist
        required = [
            "01-architecture.md",
            "02-implementation.md",
            "03-data-notes.md",
            "04-qa-report.md",
            "05-release-notes.md",
            "FINAL.md",
        ]
        missing = [f for f in required if not (run_dir / f).exists()]
        if missing:
            raise SystemExit(f"Missing required outputs: {', '.join(missing)}")

        text = checklist.read_text()
        text = text.replace("- [ ]", "- [x]")
        checklist.write_text(text)
        print(f"Approved {run_id} (checklist completed).")
        return

    if args.cmd == "run":
        task = load_yaml(Path(args.task))
        run_id = task["id"]
        project_path = Path(task["path"])
        project_cfg = load_yaml(ROOT / "projects" / f"{task['project']}.yaml")

        # deterministic gates
        for cmd in project_cfg.get("gates", {}).get("commands", []):
            import subprocess
            subprocess.run(cmd, shell=True, check=True, cwd=project_path)

        # check orchestration approval (CHECKLIST all checked)
        checklist = ROOT / "orchestration" / "runs" / run_id / "CHECKLIST.md"
        approved = False
        if checklist.exists():
            text = checklist.read_text()
            approved = "- [ ]" not in text

        # git diff
        import subprocess
        diff = subprocess.run(["git", "status", "--porcelain"], cwd=project_path, capture_output=True, text=True, check=True).stdout.strip()

        if not diff:
            print(f"No changes for {run_id}. Nothing to commit.")
            return

        branch = f"run/{run_id}"
        subprocess.run(["git", "checkout", "-b", branch], cwd=project_path, check=True)
        subprocess.run(["git", "add", "-A"], cwd=project_path, check=True)
        subprocess.run(["git", "commit", "-m", f"{task['goal']}"], cwd=project_path, check=True)
        subprocess.run(["git", "push", "-u", "origin", branch], cwd=project_path, check=True)

        if project_cfg.get("autopr", False) and approved:
            subprocess.run([
                "gh", "pr", "create",
                "--repo", project_cfg["repo"],
                "--title", task["goal"],
                "--body", f"Run: {run_id}\n\nAuto-generated by pipeline-core."
            ], cwd=project_path, check=True)
            print(f"PR opened for {run_id}.")
        else:
            print(f"Branch pushed for {run_id}. PR not opened (approved={approved}).")
        return


if __name__ == "__main__":
    main()
